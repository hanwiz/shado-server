package server.Input;
import server.Engine.Replication;
import server.Engine.Task;
import server.Output.TaskRecord;
import server.Output.Utilization;
import server.Output.WaitTime;

import java.util.*;

/***************************************************************************
 * 
 * 	FILE: 			loadparam.java
 * 
 * 	AUTHOR: 		BRANCH VINCENT
 * 
 * 	TRANSLATOR: 	ROCKY LI, RICHARD CHEN, NAIXIN YU
 * 	
 * 	LATEST EDIT:	2018/8/3
 * 
 * 	VER: 			1.0 SHOW
 * 					1.1 SHADO
 * 				    2.0 SHADO
 *
 * 	Purpose: 		Load vars from the received json file.
 * 
 **************************************************************************/

public class loadparam {

    // Parameters from json file:
	
	// Global input variables
	public double       numHours;
    public int          numReps;
    public int[]        hasTurnOver;
    public char[]       turnOverDists;
    public double[][]   turnOverPms;
    public int []       hasExogenous;

    // Team Variables
    public int          numTeams;
    public int          hasFlexPosition;
    public int          flexTeamSize;
    public int[]        teamSize;
    public String[]     opNames;
    public String[]     opStrats;
    public int[][][]    opExpertise; //team * task * fleet
    public int[][]      taskPrty; //team * task
    public char[]       teamComm;
    public double[][]   ECC; //short for "Error Catching Chance"

    //AIDA Variables
    public int[][]      AIDAtype;
    public double[]     ETServiceTime;
    public double[]     ETErrorRate;
    public double[]     ETFailThreshold;
    public int[][]      IAtasks;
    public char[]       IALevel;
    public char[]       TCALevel;

    // Fleet Variables
    public int          fleetTypes;
    public String[]     fleetNames;
    public int[]        numvehicles;
    public char[]       autolvl;
    public int[][]      fleetHetero;
    public double[][]   traffic;  //[fleet][hours]

    // Task Variables
    public int          numTaskTypes;
    public String[]     taskNames;
    public char[]       arrDists;
    public double[][]   arrPms;
    public char[]       serDists;
    public double[][]   serPms;
    public char[]       expDists;
    public double[][]   expPms;
    public int[]        affByTraff;
    public int[]        teamCoordAff;
    public double[][]   humanError;
    public int[]        interruptable;
    public int[]        essential;
    public int[]        leadTask;
    public int[]        exoType2Aff;


    // Parameters created by this program:

    // Constant Values

    public int          TC_SOME_TASK;
    public int          TC_FULL_TASK;
    public int          EXOGENOUS_TASK;
    public int          TURN_OVER_BEGIN_TASK;
    public int          TURN_OVER_END_TASK;
    public int          FLEXTEAM;
    public int          OTHER_SOURCES;


    // Other parameters

    public int          numPhases;
    public double[]     phaseBegin;
    public String[]     taskName_all;  //taskNames + special task name
    public int          totalTaskType; //numTaskTypes + #special tasks
    public Set<Integer> allTaskTypes;  //task types + special task type
    public String[]     teamName_all;  //teamNames + flexPosition
    public int          numRemoteOp;   //# of operators except for flex position
    public int[][]      ETteam; //[taks][fleet]: which team has ET for this task type this fleet
    public boolean      hasET = false;
    public int          replicationTracker; //keep record of the current replication
    public double[]     humanErrorRate; //This is a variable generated by humanError distribution, refreashed in each replication
    public ArrayList<ArrayList<Integer>> followedTask;


    // Records variables

    public Replication[]                                reps;
    //public HashMap<Integer,ArrayList<Pair <Operator,Task>>> rep_failTask;
    public TaskRecord                                   taskRecord;
    public Utilization                                  utilization;
    public WaitTime                                     waitTime;
    public ArrayList<ArrayList<Task>>                   allTasksPerRep;
    public ArrayList<Task>                              AITasks;
    //public ArrayList<ArrayList<Pair<Operator,Task>>>    expiredTasks;
    public double[][]                                   crossRepCount;
    public int[]                                        repNumTasks;


	/****************************************************************************
	*																			
	*	Shado Object:	loadvars
	*																			
	*	Purpose:		Load vars from the received json file.
	*																			
	****************************************************************************/
	public loadparam(){

    }

    /****************************************************************************
     *
     *	Method:	        setGlobalData
     *
     *	Purpose:		Expand the essential ans interruptable matrixes to include
     *                  special tasks.
     *
     ****************************************************************************/
    public void setGlobalData() {

        // Set values for constant variables

        TC_SOME_TASK = numTaskTypes;
        TC_FULL_TASK = numTaskTypes + 1;
        EXOGENOUS_TASK = numTaskTypes + 2;
        TURN_OVER_BEGIN_TASK = numTaskTypes + 3;
        TURN_OVER_END_TASK = numTaskTypes + 4;
        FLEXTEAM = numTeams;
        totalTaskType = numTaskTypes + 5;

        if (fleetNames[fleetTypes - 1].equals("Other Sources"))
            OTHER_SOURCES = (fleetTypes - 1) * 100;
        else
            OTHER_SOURCES = -1;

        // Add teamSize if it has equal operator
        for(int i = 0; i < teamSize.length; i++){
            teamSize[i] += + AIDAtype[i][0];
        }

        // Expand matrixes to include special tasks

        expandEssential();
        expandInterruptable();
        getNumRemoteOp();
        collectTaskNames();
        collectTeamNames();
        collectTaskTypes();
        setPhase();

        // Initialize variables

        taskRecord = new TaskRecord(this);
        utilization = new Utilization(this);
        waitTime = new WaitTime(this);
        replicationTracker = 0;
        allTasksPerRep = new ArrayList<>();
        crossRepCount = new double[numReps][];
        repNumTasks = new int[numReps];
        humanErrorRate = new double[totalTaskType];
        AITasks = new ArrayList<>();
        reps = new Replication[numReps];
        //rep_failTask = new HashMap<>();
        //expiredTasks = new ArrayList<ArrayList<Pair<Operator,Task>>>();
        // for(int i = 0; i < numReps; i++){
        //     expiredTasks.add(new ArrayList<Pair<Operator, Task>>());
        // }

        int maxTeamSize = 0;
        for(int i = 0; i < teamSize.length; i++){
            if(teamSize[i] > maxTeamSize){
                maxTeamSize = teamSize[i];
            }
        }

        // create the followed task matrx
        // checkFollowedTask();
    }

    /****************************************************************************
     *
     *	Method:	        expandEssential, expandInterruptable
     *
     *	Purpose:		Expand the essential ans interruptable matrixes to include
     *                  special tasks.
     *
     ****************************************************************************/

    private void expandEssential(){

        int l = essential.length;
        int[] fullEssential = new int[l + 5];
        for (int i = 0; i < l; i++){
            fullEssential[i] = essential[i];
        }
        fullEssential[l] = 0;       // team communication task (some)
        fullEssential[l + 1] = 0;   // team communication task (full)
        fullEssential[l + 2] = 1;   // exogenous task
        fullEssential[l + 3] = 1;   // turn over task (begin)
        fullEssential[l + 4] = 1;   // turn over task (end)

        essential = fullEssential;

    }

    private void expandInterruptable(){

        int l = interruptable.length;
        int[] fullInterruptable = new int[l + 5];
        for (int i = 0; i < l; i++){
            fullInterruptable[i] = interruptable[i];
        }
        fullInterruptable[l]     = 1;   // team communication task (some)
        fullInterruptable[l + 1] = 1;   // team communication task (full)
        fullInterruptable[l + 2] = 0;   // exogenous task
        fullInterruptable[l + 3] = 0;   // turn over task (beign)
        fullInterruptable[l + 4] = 0;   // turn over task (end)

        interruptable = fullInterruptable;

    }

    /****************************************************************************
     *
     *	Method:	        setPhase
     *
     *	Purpose:		Initialize the phase setting based on turn over tasks.
     *
     ****************************************************************************/

    private void setPhase(){

        //compute phase number
        numPhases = 1 + hasTurnOver[0] + hasTurnOver[1];

        //build phaseBegin vector
        phaseBegin = new double[numPhases + 1];
        phaseBegin[0] = 0;
        phaseBegin[numPhases] = numHours * 60;

    }


    /****************************************************************************
     *
     *	Method:	        getNumRemoteOp
     *
     *	Purpose:		Compute the total number of operators in all the teams
     *
     ****************************************************************************/

    private void getNumRemoteOp(){
        numRemoteOp = 0;
        for(int i=0; i<numTeams;i++){
            numRemoteOp += teamSize[i];
        }
    }

    /****************************************************************************
     *
     *	Method:	        collectTeamNames
     *
     *	Purpose:		Put the team name, flex position team name
     *
     ****************************************************************************/

    private void collectTeamNames(){

        String[] specialTeamName = {"Flex Position"};
        teamName_all = new String[numTeams + hasFlexPosition];
        for (int i = 0; i < numTeams + hasFlexPosition; i++) {
            if (i < numTeams) {
                teamName_all[i] = opNames[i];
            }
            else {
                teamName_all[i] = specialTeamName[i - numTeams];
            }
        }
    }

    /****************************************************************************
     *
     *	Method:	        collectTaskNames
     *
     *	Purpose:		Put the task name, followed task name, TC task name and
     *              	Exogenous task name into one matrix.
     *
     ****************************************************************************/

    private void collectTaskNames(){

        String[] specialTaskName = {"TC task (some)", "TC task (full)", "Exogenous task", "Turn Over Task (begin)", "Turn Over Task (end)"};
        taskName_all = new String[totalTaskType];
        for (int i = 0; i < totalTaskType; i++) {
            if (i < numTaskTypes) {
                taskName_all[i] = taskNames[i];
            }
            else {
                taskName_all[i] = specialTaskName[i - numTaskTypes];
            }
        }

    }


    /****************************************************************************
     *
     *	Method:	        collectTaskTypes
     *
     *	Purpose:		Create a list of all the exist task types, including
     *              	regular tasks, followed task, TC tasks and Exogenous task.
     *
     ****************************************************************************/

    private void collectTaskTypes(){

        allTaskTypes = new HashSet<>();

        for(int i = 0; i < numTaskTypes; i++)
            allTaskTypes.add(i);

        for (Character c: teamComm) {
            if (c.equals('S'))
                allTaskTypes.add(TC_SOME_TASK);
            if (c.equals('F'))
                allTaskTypes.add(TC_FULL_TASK);
        }

        // int sum = 0;
        // for (int i : hasExogenous) {
        //     sum += i;
        // }
        if (hasExogenous[0] == 1)
            allTaskTypes.add(EXOGENOUS_TASK);

        if (hasTurnOver[0] == 1)
            allTaskTypes.add(TURN_OVER_BEGIN_TASK);
        if (hasTurnOver[1] == 1)
            allTaskTypes.add(TURN_OVER_END_TASK);

    }


    // /****************************************************************************
    //  *
    //  *	Method:	        checkFollowedTask
    //  *
    //  *	Purpose:		Build the followedTask matrix to record the followed tasks'
    //  *                  type for each task.
    //  *
    //  ****************************************************************************/
    // private void checkFollowedTask(){

    //     followedTask = new ArrayList<>();
    //     for(int i = 0; i < leadTask.length; i++){
    //         ArrayList<Integer> n = new ArrayList<>();
    //         followedTask.add(n);
    //     }

    //     for (int i = 0; i < leadTask.length; i++) {
    //         if (leadTask[i] >= 0) {
    //             followedTask.get(leadTask[i]).add(i);
    //         }
    //     }

    // }



    /****************************************************************************
     *
     *	Method:		    refreshHumanErrorRate
     *
     *	Purpose:	    generate a new human error rate for each replication
     *
     ****************************************************************************/

    public void refreshHumanErrorRate(){

        for (int taskType = 0; taskType < numTaskTypes; taskType++) {
            humanErrorRate[taskType] = getTriangularDistribution(humanError[taskType]);
        }

        double[] specialTaskHumanError = { 0.002, 0.003, 0.004 };

        for(int i = 0; i < totalTaskType - numTaskTypes; i++) {
            humanErrorRate[numTaskTypes + i] = getTriangularDistribution(specialTaskHumanError);
        }

    }

    /****************************************************************************
     *
     *	Method:		    getTriangularDistribution
     *
     *	Purpose:	    generate a TriangularDistribution value for human error prediction
     *
     ****************************************************************************/
    private double getTriangularDistribution(double[] triangularParams){

        double c = triangularParams[1]; //mode
        double a = triangularParams[0]; //min
        double b = triangularParams[2]; //max

        double F = (c - a)/(b - a);
        double rand = Math.random();
        if (rand < F) {
            return a + Math.sqrt(rand * (b - a) * (c - a));
        } else {
            return b - Math.sqrt((1 - rand) * (b - a) * (b - c));
        }

    }

//
//	public loadparam(String file) throws FileNotFoundException{
//
//		//Declare a scanner for the file
//
//		Scanner in = new Scanner(new File(file));
//
//		//Read the header of the file
//
//		outputPath = readString(in);
//		numHours = readDouble(in);
//		traffic = readTraff(in);
//		numReps = readInt(in);
//		//SCHEN 11/10/17 fleetTypes represents the combination of different vehicles
//		fleetTypes = readInt(in);
//        failTaskCount = new HashMap<>();
//       	replicationTracker = 0;
//		crossRepCount = new double[numReps][];
//
//		//SCHEN 11/10/17 Read numvehicles Array
////		numvehicles = readInt(in);
//		numvehicles = readIntArr(in);
//		numTeams = readInt(in);
//		numRemoteOp = readInt(in);
//		RemoteOpTasks = readIntArr(in);
//		numTaskTypes = readInt(in);
//        numPhases = readInt(in);
//		//SCHEN 12/4/15 Fleet Autonomous level
//		autolvl = readInt(in);
////		teamComm = readInt(in);
//		hasExogenous = readIntArr(in);
//        opStrats = readString(in);
//		failThreshold = readDouble(in);
//		reps = new Replication[numReps];
//		rep_failTask = new HashMap<>();
//		expiredTasks = new ArrayList<ArrayList<Pair<Operator,Task>>>();
//		for(int i = 0; i < numReps; i++){
//			expiredTasks.add(new ArrayList<Pair<Operator, Task>>());
//		}
//
//		//Has exo-factors
//		int numExos = hasExogenous[1];
//        exNames = new String[numExos];
//        exTypes = new String[numExos];
//        for(int i = 0; i < numExos; i++){
//            exNames[i] = readString(in);
//            exTypes[i] = readString(in);
//        }
//
//
//		//SCHEN 11/10/2017
//		//Load Fleet Heterogeneity info
//
//		fleetHetero = new int[fleetTypes][];
//		for(int i = 0 ; i < fleetTypes; i++){
//			fleetHetero[i] = readIntArr(in);
//		}
//
//
//        //SCHEN 1/20/2018 Individualize team_comm to each operator type
//		teamSizeTotal = 0;
//		opNames = new String[numTeams];
//		opTasks = new int[numTeams][];
//		teamComm = new char[numTeams];
//        teamSize = new int[numTeams];
//        ops = new int[numTeams];
//		for (int i = 0; i < numTeams; i++){
//			opNames[i] = readString(in);
//			opTasks[i] = readIntArr(in);
//
//            //Team settings
//            teamSize[i] = readInt(in);
//            teamSizeTotal += teamSize[i];
//			teamComm[i] = readChar(in);
//			ops[i] = i;
//		}
//
//
//		//Initiate array sizes
//
//
//		taskNames = new String[numTaskTypes];
//		taskPrty = new int[numTaskTypes][];
//		arrDists = new char[numTaskTypes];
//		arrPms = new double[numTaskTypes][];
//		serDists = new char[numTaskTypes];
//		serPms = new double[numTaskTypes][];
//		expDists = new char[numTaskTypes];
//	   	expPmsLo = new double[numTaskTypes][];
//	    expPmsHi = new double[numTaskTypes][];
//		affByTraff = new int[numTaskTypes][];
//		opNums = new int[numTaskTypes][];
//		linked = new int[numTaskTypes];
//		trigger = new int[numTaskTypes][];
//		teamCoordAff = new int[numTaskTypes];
//		humanError = new double[numTaskTypes][];
//
//		// Read in vehicle operators by vehicle ID.
////		for ()
//
//		//Read in agent type and tasks they can do
//
//		//Read in the task vars
//
//		for (int i = 0; i< numTaskTypes; i++){
//
//			taskNames[i] = readString(in);
//			taskPrty[i] = readIntArr(in);
//			arrDists[i] = readChar(in);
//			arrPms[i] = readDoubleArr(in);
//			serDists[i] = readChar(in);
//			serPms[i] = readDoubleArr(in);
//			expDists[i] = readChar(in);
//			expPmsLo[i] = readDoubleArr(in);
//			expPmsHi[i] = readDoubleArr(in);
//			affByTraff[i] = readIntArr(in);
//			linked[i] = readInt(in);
//			trigger[i] = readIntArr(in);
//			teamCoordAff[i] = readInt(in);
//			humanError[i] = readDoubleArr(in);
//
//		}
//
//		for (int i = 0; i < numTaskTypes; i++){
//			ArrayList<Integer> wha = new ArrayList<Integer>();
//			for (int j = 0; j < numTeams; j++){
//				if (Arrays.asList(opTasks[j]).contains(i)){
//					wha.add(j);
//				}
//			}
//			opNums[i] = wha.stream().mapToInt(Integer::intValue).toArray();
//		}
//	}
//
//	/****************************************************************************
//	*
//	*	Method:		ridvarsname
//	*
//	*	Purpose:	Read a line in the text and remove the vars name, also
//	*				returns the line as a scanner while moving the main scanner to
//	*				the next line. Also ignore lines if it's empty.
//	*
//	*	NOTE:		ALL OF THE FOLLOWING METHODS include this method to skip the
//	*				name in the file read.
//	*
//	****************************************************************************/
//
//	public Scanner ridvarsname(Scanner in){
//
//		//get rid of the vars name in source file.
//		String line = "";
//		while (true){
//			line = in.nextLine();
//			if (!line.isEmpty())
//				break;
//		}
//		Scanner input = new Scanner(line);
//		input.next();
//		return input;
//
//	}
//
//	/****************************************************************************
//	*
//	*	Method:		readString
//	*
//	*	Purpose:	Read a string line in text and return string
//	*
//	****************************************************************************/
//
//	public String readString(Scanner in){
//
//		//Read string object
//
//		Scanner input = ridvarsname(in);
//		String ret = input.nextLine();
//		ret = ret.trim();
//		input.close();
//		return ret;
//
//	}
//
//	/****************************************************************************
//	*
//	*	Method:		readTraff
//	*
//	*	Purpose:	Read traffic line in text and return a double array
//	*
//	****************************************************************************/
//
//	public double[] readTraff(Scanner in){
//
//		Scanner input = ridvarsname(in);
//
//		ArrayList<String> traff = new ArrayList<String>();
//		ArrayList<Double> traffic = new ArrayList<Double>();
//
//		while (input.hasNext()){
//			traff.add(input.next());
//		}
//
//		for (int i = 0; i<traff.size() ; i++){
//			String get = traff.get(i);
//			double myDouble = 0;
//			switch(get){
//			case "l": myDouble = 0.5; break;
//			case "m": myDouble = 1.0; break;
//			case "h": myDouble = 2.0; break;
//			}
//			traffic.add(myDouble);
//		}
//		input.close();
//
//		return traffic.stream().mapToDouble(Double::doubleValue).toArray();
//
//	}
//
//	/****************************************************************************
//	*
//	*	Method:		readInt
//	*
//	*	Purpose:	Read a integer line in text and return ONE int value
//	*
//	****************************************************************************/
//
//	public int readInt(Scanner in){
//
//		Scanner input = ridvarsname(in);
//		return input.nextInt();
//
//	}
//
//	/****************************************************************************
//	*
//	*	Method:		readDouble
//	*
//	*	Purpose:	Read a integer line in text and return ONE int value
//	*
//	****************************************************************************/
//
//	public double readDouble(Scanner in){
//
//		Scanner input = ridvarsname(in);
//		return Double.parseDouble(input.next());
//
//	}
//
//	/****************************************************************************
//	*
//	*	Method:		readIntArr
//	*
//	*	Purpose:	read an integer array from one line
//	*
//	****************************************************************************/
//
//	public int[] readIntArr(Scanner in){
//
//		Scanner input = ridvarsname(in);
//		ArrayList<Integer> ints = new ArrayList<Integer>();
//		while (input.hasNextInt()){
//			ints.add(input.nextInt());
//		}
//		input.close();
//		return ints.stream().mapToInt(Integer::intValue).toArray();
//
//	}
//
//	/****************************************************************************
//	*
//	*	Method:		readDuobleArr
//	*
//	*	Purpose:	read a double array from one line
//	*
//	****************************************************************************/
//
//	public double[] readDoubleArr(Scanner in){
//
//		Scanner input = ridvarsname(in);
//		ArrayList<Double> doubs = new ArrayList<Double>();
//		while (input.hasNext()){
//			double myDouble = Double.parseDouble(input.next());
//			doubs.add(myDouble);
//		}
//		input.close();
//		return doubs.stream().mapToDouble(Double::doubleValue).toArray();
//
//	}
//
//	/****************************************************************************
//	*
//	*	Method:		readChar
//	*
//	*	Purpose:	read a character from one line
//	*
//	****************************************************************************/
//
//	public char readChar(Scanner in){
//
//		Scanner input = ridvarsname(in);
//		char myChar = input.next().charAt(0);
//		input.close();
//		return myChar;
//
//	}
//
//	/****************************************************************************
//	*
//	*	Method:		invertArr
//	*
//	*	Purpose:	read a double array and invert each element of it unless 0
//	*
//	****************************************************************************/
//
//	public double[] invertArr(double[] input){
//
//		for (int i = 0; i<input.length ; i++){
//			if (input[i] != 0.0){
//				input[i] = 1.0/input[i];
//			}
//		}
//		return input;
//
//	}
}
